import { encode } from 'vlq';

function Patch(start, end, content, original, storeName) {
	this.start = start;
	this.end = end;
	this.content = content;
	this.original = original;
	this.storeName = storeName;
}

Patch.prototype = {
	clone: function clone() {
		return new Patch(this.start, this.end, this.content, this.original, this.storeName);
	}
};

var _btoa = undefined;

if (typeof window !== 'undefined' && typeof window.btoa === 'function') {
	_btoa = window.btoa;
} else if (typeof Buffer === 'function') {
	/* global Buffer */
	_btoa = function (str) {
		return new Buffer(str).toString('base64');
	};
} else {
	throw new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');
}

var btoa = _btoa;

function SourceMap(properties) {
	this.version = 3;

	this.file = properties.file;
	this.sources = properties.sources;
	this.sourcesContent = properties.sourcesContent;
	this.names = properties.names;
	this.mappings = properties.mappings;
}

SourceMap.prototype = {
	toString: function toString() {
		return JSON.stringify(this);
	},
	toUrl: function toUrl() {
		return 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());
	}
};

function guessIndent(code) {
	var lines = code.split('\n');

	var tabbed = lines.filter(function (line) {
		return (/^\t+/.test(line)
		);
	});
	var spaced = lines.filter(function (line) {
		return (/^ {2,}/.test(line)
		);
	});

	if (tabbed.length === 0 && spaced.length === 0) {
		return null;
	}

	// More lines tabbed than spaced? Assume tabs, and
	// default to tabs in the case of a tie (or nothing
	// to go on)
	if (tabbed.length >= spaced.length) {
		return '\t';
	}

	// Otherwise, we need to guess the multiple
	var min = spaced.reduce(function (previous, current) {
		var numSpaces = /^ +/.exec(current)[0].length;
		return Math.min(numSpaces, previous);
	}, Infinity);

	return new Array(min + 1).join(' ');
}

function encodeMappings(original, intro, patches, hires, sourcemapLocations, sourceIndex, offsets, names) {
	var rawLines = [];

	var generatedCodeLine = intro.split('\n').length - 1;
	var rawSegments = rawLines[generatedCodeLine] = [];

	var originalCharIndex = 0;

	var generatedCodeColumn = 0;
	var sourceCodeLine = 0;
	var sourceCodeColumn = 0;

	function addSegmentsUntil(end) {
		var first = true;

		while (originalCharIndex < end) {
			if (hires || first || sourcemapLocations[originalCharIndex]) {
				rawSegments.push({
					generatedCodeLine: generatedCodeLine,
					generatedCodeColumn: generatedCodeColumn,
					sourceCodeLine: sourceCodeLine,
					sourceCodeColumn: sourceCodeColumn,
					sourceCodeName: -1,
					sourceIndex: sourceIndex
				});
			}

			if (original[originalCharIndex] === '\n') {
				sourceCodeLine += 1;
				sourceCodeColumn = 0;
				generatedCodeLine += 1;
				rawLines[generatedCodeLine] = rawSegments = [];
				generatedCodeColumn = 0;
			} else {
				sourceCodeColumn += 1;
				generatedCodeColumn += 1;
			}

			originalCharIndex += 1;
			first = false;
		}
	}

	for (var i = 0; i < patches.length; i += 1) {
		var patch = patches[i];
		var addSegmentForPatch = patch.storeName || patch.start > originalCharIndex;

		addSegmentsUntil(patch.start);

		if (addSegmentForPatch) {
			rawSegments.push({
				generatedCodeLine: generatedCodeLine,
				generatedCodeColumn: generatedCodeColumn,
				sourceCodeLine: sourceCodeLine,
				sourceCodeColumn: sourceCodeColumn,
				sourceCodeName: patch.storeName ? names.indexOf(patch.original) : -1,
				sourceIndex: sourceIndex
			});
		}

		var lines = patch.content.split('\n');
		var lastLine = lines.pop();

		if (lines.length) {
			generatedCodeLine += lines.length;
			rawLines[generatedCodeLine] = rawSegments = [];
			generatedCodeColumn = lastLine.length;
		} else {
			generatedCodeColumn += lastLine.length;
		}

		lines = patch.original.split('\n');
		lastLine = lines.pop();

		if (lines.length) {
			sourceCodeLine += lines.length;
			sourceCodeColumn = lastLine.length;
		} else {
			sourceCodeColumn += lastLine.length;
		}

		originalCharIndex = patch.end;
	}

	addSegmentsUntil(original.length);

	offsets.sourceIndex = offsets.sourceIndex || 0;
	offsets.sourceCodeLine = offsets.sourceCodeLine || 0;
	offsets.sourceCodeColumn = offsets.sourceCodeColumn || 0;
	offsets.sourceCodeName = offsets.sourceCodeName || 0;

	var encoded = rawLines.map(function (segments) {
		var generatedCodeColumn = 0;

		return segments.map(function (segment) {
			var arr = [segment.generatedCodeColumn - generatedCodeColumn, segment.sourceIndex - offsets.sourceIndex, segment.sourceCodeLine - offsets.sourceCodeLine, segment.sourceCodeColumn - offsets.sourceCodeColumn];

			generatedCodeColumn = segment.generatedCodeColumn;
			offsets.sourceIndex = segment.sourceIndex;
			offsets.sourceCodeLine = segment.sourceCodeLine;
			offsets.sourceCodeColumn = segment.sourceCodeColumn;

			if (~segment.sourceCodeName) {
				arr.push(segment.sourceCodeName - offsets.sourceCodeName);
				offsets.sourceCodeName = segment.sourceCodeName;
			}

			return encode(arr);
		}).join(',');
	}).join(';');

	return encoded;
}

function getRelativePath(from, to) {
	var fromParts = from.split(/[\/\\]/);
	var toParts = to.split(/[\/\\]/);

	fromParts.pop(); // get dirname

	while (fromParts[0] === toParts[0]) {
		fromParts.shift();
		toParts.shift();
	}

	if (fromParts.length) {
		var i = fromParts.length;
		while (i--) {
			fromParts[i] = '..';
		}
	}

	return fromParts.concat(toParts).join('/');
}

var toString = Object.prototype.toString;

function isObject(thing) {
	return toString.call(thing) === '[object Object]';
}

var warned = false;

function MagicString(string) {
	var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	Object.defineProperties(this, {
		original: { writable: true, value: string },
		outro: { writable: true, value: '' },
		intro: { writable: true, value: '' },
		patches: { writable: true, value: [] },
		filename: { writable: true, value: options.filename },
		indentExclusionRanges: { writable: true, value: options.indentExclusionRanges },
		sourcemapLocations: { writable: true, value: {} },
		storedNames: { writable: true, value: {} },
		indentStr: { writable: true, value: guessIndent(string) }
	});
}

MagicString.prototype = {
	addSourcemapLocation: function addSourcemapLocation(char) {
		this.sourcemapLocations[char] = true;
	},
	append: function append(content) {
		if (typeof content !== 'string') throw new TypeError('outro content must be a string');

		this.outro += content;
		return this;
	},
	clone: function clone() {
		var cloned = new MagicString(this.original, { filename: this.filename });

		cloned.patches = this.patches.map(function (patch) {
			return patch.clone();
		});

		if (this.indentExclusionRanges) {
			cloned.indentExclusionRanges = typeof this.indentExclusionRanges[0] === 'number' ? [this.indentExclusionRanges[0], this.indentExclusionRanges[1]] : this.indentExclusionRanges.map(function (range) {
				return [range.start, range.end];
			});
		}

		Object.keys(this.sourcemapLocations).forEach(function (loc) {
			cloned.sourcemapLocations[loc] = true;
		});

		return cloned;
	},
	generateMap: function generateMap(options) {
		options = options || {};

		var names = Object.keys(this.storedNames);

		return new SourceMap({
			file: options.file ? options.file.split(/[\/\\]/).pop() : null,
			sources: [options.source ? getRelativePath(options.file || '', options.source) : null],
			sourcesContent: options.includeContent ? [this.original] : [null],
			names: names,
			mappings: this.getMappings(options.hires, 0, {}, names)
		});
	},
	getIndentString: function getIndentString() {
		return this.indentStr === null ? '\t' : this.indentStr;
	},
	getMappings: function getMappings(hires, sourceIndex, offsets, names) {
		return encodeMappings(this.original, this.intro, this.patches, hires, this.sourcemapLocations, sourceIndex, offsets, names);
	},
	indent: function indent(indentStr, options) {
		var _this = this;

		var pattern = /^[^\r\n]/gm;

		if (isObject(indentStr)) {
			options = indentStr;
			indentStr = undefined;
		}

		indentStr = indentStr !== undefined ? indentStr : this.indentStr || '\t';

		if (indentStr === '') return this; // noop

		options = options || {};

		// Process exclusion ranges
		var isExcluded = {};

		if (options.exclude) {
			var exclusions = typeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;
			exclusions.forEach(function (exclusion) {
				for (var i = exclusion[0]; i < exclusion[1]; i += 1) {
					isExcluded[i] = true;
				}
			});
		}

		var shouldIndentNextCharacter = options.indentStart !== false;
		var replacer = function replacer(match) {
			if (shouldIndentNextCharacter) return '' + indentStr + match;
			shouldIndentNextCharacter = true;
			return match;
		};

		this.intro = this.intro.replace(pattern, replacer);

		var charIndex = 0;
		var patchIndex = 0;

		var indentUntil = function indentUntil(end) {
			while (charIndex < end) {
				if (!isExcluded[charIndex]) {
					var char = _this.original[charIndex];

					if (char === '\n') {
						shouldIndentNextCharacter = true;
					} else if (char !== '\r' && shouldIndentNextCharacter) {
						_this.patches.splice(patchIndex, 0, new Patch(charIndex, charIndex, indentStr, '', false));
						shouldIndentNextCharacter = false;

						patchIndex += 1;
					}
				}

				charIndex += 1;
			}
		};

		for (; patchIndex < this.patches.length; patchIndex += 1) {
			// can't cache this.patches.length, it may change
			var patch = this.patches[patchIndex];

			indentUntil(patch.start);

			if (!isExcluded[charIndex]) {
				patch.content = patch.content.replace(pattern, replacer);

				if (patch.content.length) {
					shouldIndentNextCharacter = patch.content[patch.content.length - 1] === '\n';
				}
			}

			charIndex = patch.end;
		}

		indentUntil(this.original.length);

		this.outro = this.outro.replace(pattern, replacer);

		return this;
	},
	insert: function insert(index, content) {
		if (typeof content !== 'string') {
			throw new TypeError('inserted content must be a string');
		}

		this.patch(index, index, content);
		return this;
	},

	// get current location of character in original string
	locate: function locate(character) {
		throw new Error('magicString.locate is deprecated');
	},
	locateOrigin: function locateOrigin(character) {
		throw new Error('magicString.locateOrigin is deprecated');
	},
	overwrite: function overwrite(start, end, content, storeName) {
		if (typeof content !== 'string') {
			throw new TypeError('replacement content must be a string');
		}

		this.patch(start, end, content, storeName);
		return this;
	},
	patch: function patch(start, end, content, storeName) {
		var original = this.original.slice(start, end);
		if (storeName) this.storedNames[original] = true;

		var i = this.patches.length;
		while (i--) {
			var previous = this.patches[i];

			// TODO can we tidy this up?

			// if this completely covers previous patch, remove it
			if (start !== end && start <= previous.start && end >= previous.end) {
				// unless it's an insert at the start
				if (previous.start === previous.end && previous.start === start) break;
				// or it's an insert at the end
				if (previous.start === previous.end && previous.end === end) continue;
				this.patches.splice(i, 1);
			}

			// if it overlaps, throw error
			else if (start < previous.end && end > previous.start) {
					// special case – it's okay to remove overlapping ranges
					if (!previous.content.length && !content.length) {
						previous.start = Math.min(start, previous.start);
						previous.end = Math.max(end, previous.end);
						return;
					}

					throw new Error('Cannot overwrite the same content twice: \'' + original + '\'');
				}

				// if this precedes previous patch, stop search
				else if (start >= previous.end) {
						break;
					}
		}

		var patch = new Patch(start, end, content, original, storeName);
		this.patches.splice(i + 1, 0, patch);
		return patch;
	},
	prepend: function prepend(content) {
		if (typeof content !== 'string') throw new TypeError('outro content must be a string');

		this.intro = content + this.intro;
		return this;
	},
	remove: function remove(start, end) {
		if (start < 0 || end > this.original.length) {
			throw new Error('Character is out of bounds');
		}

		this.patch(start, end, '');
		return this;
	},
	replace: function replace(start, end, content) {
		if (!warned) {
			console.warn('magicString.replace(...) is deprecated. Use magicString.overwrite(...) instead');
			warned = true;
		}

		return this.overwrite(start, end, content);
	},
	slice: function slice(start) {
		var end = arguments.length <= 1 || arguments[1] === undefined ? this.original.length : arguments[1];

		while (start < 0) {
			start += this.original.length;
		}while (end < 0) {
			end += this.original.length;
		}var firstPatchIndex = 0;
		var lastPatchIndex = this.patches.length;

		while (lastPatchIndex--) {
			var patch = this.patches[lastPatchIndex];
			if (end >= patch.start && end < patch.end) throw new Error('Cannot use replaced characters (' + start + ', ' + end + ') as slice anchors');

			// TODO this is weird, rewrite it
			if (patch.start > end) continue;
			break;
		}

		for (firstPatchIndex = 0; firstPatchIndex <= lastPatchIndex; firstPatchIndex += 1) {
			var patch = this.patches[firstPatchIndex];
			if (start > patch.start && start <= patch.end) throw new Error('Cannot use replaced characters (' + start + ', ' + end + ') as slice anchors');

			if (start <= patch.start) {
				break;
			}
		}

		var result = '';
		var lastIndex = start;

		for (var i = firstPatchIndex; i <= lastPatchIndex; i += 1) {
			var patch = this.patches[i];
			result += this.original.slice(lastIndex, patch.start);
			result += patch.content;

			lastIndex = patch.end;
		}

		result += this.original.slice(lastIndex, end);

		return result;
	},
	snip: function snip(start, end) {
		var clone = this.clone();
		clone.remove(0, start);
		clone.remove(end, clone.original.length);

		return clone;
	},
	toString: function toString() {
		return this.intro + this.slice(0, this.original.length) + this.outro;
	},
	trimLines: function trimLines() {
		return this.trim('[\\r\\n]');
	},
	trim: function trim(charType) {
		return this.trimStart(charType).trimEnd(charType);
	},
	trimEnd: function trimEnd(charType) {
		var rx = new RegExp((charType || '\\s') + '+$');

		this.outro = this.outro.replace(rx, '');
		if (this.outro.length) return this;

		var charIndex = this.original.length;
		var i = this.patches.length;

		while (i--) {
			var patch = this.patches[i];

			if (charIndex > patch.end) {
				var _slice = this.original.slice(patch.end, charIndex);

				var _match = rx.exec(_slice);
				if (_match) {
					this.patch(charIndex - _match[0].length, charIndex, '');
				}

				if (!_match || _match[0].length < _slice.length) {
					// there is non-whitespace after the patch
					return this;
				}
			}

			patch.content = patch.content.replace(rx, '');
			if (patch.content) return this;

			charIndex = patch.start;
		}

		var slice = this.original.slice(0, charIndex);

		var match = rx.exec(slice);
		if (match) this.patch(charIndex - match[0].length, charIndex, '');

		return this;
	},
	trimStart: function trimStart(charType) {
		var rx = new RegExp('^' + (charType || '\\s') + '+');

		this.intro = this.intro.replace(rx, '');
		if (this.intro.length) return this;

		var charIndex = 0;

		for (var i = 0; i < this.patches.length; i += 1) {
			var patch = this.patches[i];

			if (charIndex < patch.start) {
				var _slice2 = this.original.slice(charIndex, patch.start);

				var _match2 = rx.exec(_slice2);
				if (_match2) this.patch(charIndex, charIndex + _match2[0].length, '');

				if (!_match2 || _match2[0].length < _slice2.length) {
					// there is non-whitespace before the patch
					return this;
				}
			}

			patch.content = patch.content.replace(rx, '');
			if (patch.content) return this;

			charIndex = patch.end;
		}

		var slice = this.original.slice(charIndex, this.original.length);

		var match = rx.exec(slice);
		if (match) this.patch(charIndex, charIndex + match[0].length, '');

		return this;
	}
};

var hasOwnProp = Object.prototype.hasOwnProperty;

function Bundle() {
	var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	this.intro = options.intro || '';
	this.separator = options.separator !== undefined ? options.separator : '\n';

	this.sources = [];

	this.uniqueSources = [];
	this.uniqueSourceIndexByFilename = {};
}

Bundle.prototype = {
	addSource: function addSource(source) {
		if (source instanceof MagicString) {
			return this.addSource({
				content: source,
				filename: source.filename,
				separator: this.separator
			});
		}

		if (!isObject(source) || !source.content) {
			throw new Error('bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`');
		}

		['filename', 'indentExclusionRanges', 'separator'].forEach(function (option) {
			if (!hasOwnProp.call(source, option)) source[option] = source.content[option];
		});

		if (source.separator === undefined) {
			// TODO there's a bunch of this sort of thing, needs cleaning up
			source.separator = this.separator;
		}

		if (source.filename) {
			if (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {
				this.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;
				this.uniqueSources.push({ filename: source.filename, content: source.content.original });
			} else {
				var uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];
				if (source.content.original !== uniqueSource.content) {
					throw new Error('Illegal source: same filename (' + source.filename + '), different contents');
				}
			}
		}

		this.sources.push(source);
		return this;
	},
	append: function append(str, options) {
		this.addSource({
			content: new MagicString(str),
			separator: options && options.separator || ''
		});

		return this;
	},
	clone: function clone() {
		var bundle = new Bundle({
			intro: this.intro,
			separator: this.separator
		});

		this.sources.forEach(function (source) {
			bundle.addSource({
				filename: source.filename,
				content: source.content.clone(),
				separator: source.separator
			});
		});

		return bundle;
	},
	generateMap: function generateMap(options) {
		var _this = this;

		var offsets = {};

		var names = [];
		this.sources.forEach(function (source) {
			Object.keys(source.content.storedNames).forEach(function (name) {
				if (! ~names.indexOf(name)) names.push(name);
			});
		});

		var encoded = getSemis(this.intro) + this.sources.map(function (source, i) {
			var prefix = i > 0 ? getSemis(source.separator) || ',' : '';
			var mappings = undefined;

			// we don't bother encoding sources without a filename
			if (!source.filename) {
				mappings = getSemis(source.content.toString());
			} else {
				var sourceIndex = _this.uniqueSourceIndexByFilename[source.filename];
				mappings = source.content.getMappings(options.hires, sourceIndex, offsets, names);
			}

			return prefix + mappings;
		}).join('');

		return new SourceMap({
			file: options.file ? options.file.split(/[\/\\]/).pop() : null,
			sources: this.uniqueSources.map(function (source) {
				return options.file ? getRelativePath(options.file, source.filename) : source.filename;
			}),
			sourcesContent: this.uniqueSources.map(function (source) {
				return options.includeContent ? source.content : null;
			}),
			names: names,
			mappings: encoded
		});
	},
	getIndentString: function getIndentString() {
		var indentStringCounts = {};

		this.sources.forEach(function (source) {
			var indentStr = source.content.indentStr;

			if (indentStr === null) return;

			if (!indentStringCounts[indentStr]) indentStringCounts[indentStr] = 0;
			indentStringCounts[indentStr] += 1;
		});

		return Object.keys(indentStringCounts).sort(function (a, b) {
			return indentStringCounts[a] - indentStringCounts[b];
		})[0] || '\t';
	},
	indent: function indent(indentStr) {
		var _this2 = this;

		if (!arguments.length) {
			indentStr = this.getIndentString();
		}

		if (indentStr === '') return this; // noop

		var trailingNewline = !this.intro || this.intro.slice(-1) === '\n';

		this.sources.forEach(function (source, i) {
			var separator = source.separator !== undefined ? source.separator : _this2.separator;
			var indentStart = trailingNewline || i > 0 && /\r?\n$/.test(separator);

			source.content.indent(indentStr, {
				exclude: source.indentExclusionRanges,
				indentStart: indentStart //: trailingNewline || /\r?\n$/.test( separator )  //true///\r?\n/.test( separator )
			});

			// TODO this is a very slow way to determine this
			trailingNewline = source.content.toString().slice(0, -1) === '\n';
		});

		if (this.intro) {
			this.intro = indentStr + this.intro.replace(/^[^\n]/gm, function (match, index) {
				return index > 0 ? indentStr + match : match;
			});
		}

		return this;
	},
	prepend: function prepend(str) {
		this.intro = str + this.intro;
		return this;
	},
	toString: function toString() {
		var _this3 = this;

		var body = this.sources.map(function (source, i) {
			var separator = source.separator !== undefined ? source.separator : _this3.separator;
			var str = (i > 0 ? separator : '') + source.content.toString();

			return str;
		}).join('');

		return this.intro + body;
	},
	trimLines: function trimLines() {
		return this.trim('[\\r\\n]');
	},
	trim: function trim(charType) {
		return this.trimStart(charType).trimEnd(charType);
	},
	trimStart: function trimStart(charType) {
		var rx = new RegExp('^' + (charType || '\\s') + '+');
		this.intro = this.intro.replace(rx, '');

		if (!this.intro) {
			var source = undefined;
			var i = 0;

			do {
				source = this.sources[i];

				if (!source) {
					break;
				}

				source.content.trimStart(charType);
				i += 1;
			} while (source.content.toString() === ''); // TODO faster way to determine non-empty source?
		}

		return this;
	},
	trimEnd: function trimEnd(charType) {
		var rx = new RegExp((charType || '\\s') + '+$');

		var source = undefined;
		var i = this.sources.length - 1;

		do {
			source = this.sources[i];

			if (!source) {
				this.intro = this.intro.replace(rx, '');
				break;
			}

			source.content.trimEnd(charType);
			i -= 1;
		} while (source.content.toString() === ''); // TODO faster way to determine non-empty source?

		return this;
	}
};

function getSemis(str) {
	return new Array(str.split('\n').length).join(';');
}

MagicString.Bundle = Bundle;

export default MagicString;
//# sourceMappingURL=magic-string.es6.js.map